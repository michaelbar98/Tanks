package edu.brown.cs.bdGaMbPp.Collect;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import com.google.common.collect.ImmutableList;

/**
 * A Path is a list of pathNodes that is generated by Dijkstra.
 *
 * @author prithudasgupta
 *
 * @param <V>
 *          type of nodes in graph
 * @param <E>
 *          type of edges in graph
 */
public class Path<V, E> {

  private List<PathNode<V, E>> thePath;
  private double length;
  private boolean pathExists;

  /**
   * Creates an empty path that does not exist.
   */
  public Path() {
    thePath = new ArrayList<PathNode<V, E>>();
    length = 0.0;
    pathExists = false;

  }

  /**
   * Creates a path that does exist.
   *
   * @param sourceId
   *          start of the path
   * @param destinationId
   *          end of the path
   * @param predecessors
   *          dictionary of predecessors
   * @param aGraph
   *          graph of the path
   * @param weight
   *          weight of the path
   */
  public Path(String sourceId, String destinationId,
      Map<String, String> predecessors, Graph<V, E> aGraph, double weight) {
    thePath = createPath(sourceId, destinationId, predecessors, aGraph,
        new ArrayList<PathNode<V, E>>());
    length = weight;
    pathExists = true;

  }

  /**
   * Returns path length.
   *
   * @return path weight
   */
  public double getPathLength() {
    return length;
  }

  /**
   * Returns boolean if path exists.
   *
   * @return boolean for existence of path
   */
  public boolean pathExists() {
    return pathExists;
  }

  private PathNode<V, E> pathCreatorHelper(String fromId, String toId,
      Graph<V, E> aGraph) {
    // creates current pathNode given source and destination ids
    GraphNode<V, E> prev = aGraph.getNodeByID(fromId);
    return new PathNode<V, E>(prev.getVertex(),
        aGraph.getNodeByID(toId).getVertex(), prev.getEdge(toId));
  }

  private List<PathNode<V, E>> createPath(String sourceId, String destinationId,
      Map<String, String> predecessors, Graph<V, E> aGraph,
      List<PathNode<V, E>> builtPath) {
    // recurs through predecessor dictionary and builds path
    if (sourceId.equals(destinationId)) {
      return builtPath;
    } else {
      String prevId = predecessors.get(destinationId);
      builtPath.add(0, pathCreatorHelper(prevId, destinationId, aGraph));
      return createPath(sourceId, prevId, predecessors, aGraph, builtPath);
    }

  }

  /**
   * Returns list with current path.
   *
   * @return List of the path.
   */
  public List<PathNode<V, E>> getPath() {
    return ImmutableList.copyOf(thePath);
  }

  @Override
  public String toString() {

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < thePath.size(); i++) {
      sb.append(thePath.get(i).toString());
      if (i != thePath.size() - 1) {
        sb.append('\n');
      }
    }
    return sb.toString();

  }
}
